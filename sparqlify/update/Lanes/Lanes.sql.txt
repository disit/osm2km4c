/* OSM2KM4C
   Copyright (C) 2017 DISIT Lab http://www.disit.org - University of Florence

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Affero General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

-- CONFIGURAZIONE DELL'INSTALLAZIONE
------------------------------------

-- Delimitazione geografica dell'installazione

drop table if exists extra_config_boundaries; 

create table extra_config_boundaries as 
select * from extra_all_boundaries where relation_id in (276369);

create index extra_config_boundaries_index_1 on extra_config_boundaries using gist(boundary);

create index extra_config_boundaries_index_2 on extra_config_boundaries using gist(bbox);

create index extra_config_boundaries_index_3 on extra_config_boundaries using gist(centroid);

-- Grafo

drop table if exists extra_config_graph ;

create table extra_config_graph (
id serial primary key,
graph_uri varchar(255)
);

insert into extra_config_graph(graph_uri) values ('http://www.disit.org/km4city/graph/OSM/CA'); 

-- Utilizzo dei numeri civici della Regione Toscana piuttosto che nativi di OSM

drop table if exists extra_config_civic_num ;

create table extra_config_civic_num (
id serial primary key,
civic_num_source varchar(255)
);

-- insert into extra_config_civic_num(civic_num_source) values ('Regione Toscana'); -- decommentare questa riga per utilizzare i numeri civici della Regione Toscana
insert into extra_config_civic_num(civic_num_source) values ('Open Street Map'); -- decommentare questa riga per utilizzare i numeri civici nativi di Open Street Map

/********************************************
************ TABELLE DI APPOGGIO ************
*********************************************/

-- Esplosione delle way

drop table if exists extra_ways;

create table extra_ways as
select prev_waynode.way_id global_id, prev_waynode.sequence_id local_id, prev_node.geom start_node, next_node.geom end_node, prev_node.id prev_node_id, next_node.id next_node_id
from way_nodes prev_waynode 
join nodes prev_node on prev_waynode.node_id = prev_node.id
join way_nodes next_waynode on prev_waynode.way_id = next_waynode.way_id and prev_waynode.sequence_id = next_waynode.sequence_id-1
join nodes next_node on next_waynode.node_id = next_node.id
join way_tags on prev_waynode.way_id = way_tags.way_id and way_tags.k = 'highway' and way_tags.v <> 'proposed'
join extra_config_boundaries boundaries on ST_Covers(boundaries.boundary, next_node.geom);

create index on extra_ways (global_id);

create index on extra_ways using gist(start_node);

create index on extra_ways using gist(end_node);

-- Comuni di interesse

drop table if exists extra_comuni;

create table extra_comuni as
select relations.id relation_id, extra_all_boundaries.centroid, extra_all_boundaries.boundary boundary, extra_all_boundaries.bbox bbox
from relations 
join relation_tags tag_type on relations.id = tag_type.relation_id and tag_type.k = 'type' and tag_type.v = 'boundary'
join relation_tags boundary on relations.id = boundary.relation_id and boundary.k = 'boundary' and boundary.v = 'administrative'
join relation_tags admin_level on relations.id = admin_level.relation_id and admin_level.k = 'admin_level' and admin_level.v = '8' 
-- join relation_tags catasto on relations.id = catasto.relation_id and catasto.k = 'ref:catasto' -- taglio sugli italiani
join extra_all_boundaries on relations.id = extra_all_boundaries.relation_id
join extra_config_boundaries on ST_Covers(extra_config_boundaries.boundary, extra_all_boundaries.boundary);

create index extra_comuni_index_1 on extra_comuni using gist(centroid);

create index extra_comuni_index_2 on extra_comuni using gist(boundary);

create index extra_comuni_index_3 on extra_comuni using gist(bbox);

-- Province di interesse

drop table if exists extra_province;

create table extra_province as
select relations.id relation_id, extra_all_boundaries.centroid, extra_all_boundaries.boundary boundary, extra_all_boundaries.bbox bbox
from relations 
join relation_tags tag_type on relations.id = tag_type.relation_id and tag_type.k = 'type' and tag_type.v = 'boundary'
join relation_tags boundary on relations.id = boundary.relation_id and boundary.k = 'boundary' and boundary.v = 'administrative'
join relation_tags admin_level on relations.id = admin_level.relation_id and admin_level.k = 'admin_level' and admin_level.v = '6' 
join extra_all_boundaries on relations.id = extra_all_boundaries.relation_id
join extra_config_boundaries on ST_Covers(extra_config_boundaries.boundary, extra_all_boundaries.boundary);

create index extra_province_index_1 on extra_province using gist(centroid);

create index extra_province_index_2 on extra_province using gist(boundary);

create index extra_province_index_3 on extra_province using gist(bbox);

-- Corrispondenze tra comuni e province

drop table if exists extra_city_county ;

create table extra_city_county as
select extra_comuni.relation_id comune, province_short_name.v provincia
from extra_comuni, extra_province, relation_tags province_short_name
where ST_Covers(extra_province.boundary,extra_comuni.boundary)
and extra_province.relation_id = province_short_name.relation_id
and province_short_name.k = 'short_name';

-- Quartieri

drop table if exists extra_suburbs;

create table extra_suburbs as
select suburb.id, suburb.centroid, suburb.boundary, suburb.suburb_type, suburb.suburb_name, extra_comuni.relation_id municipality_id
from 
(
-- suburb ways
select ways.id, 
	ST_GeomFromText(ST_AsText(ST_Centroid(ST_ConvexHull(ST_Collect(ways.linestring)))),4326) centroid, 
	ST_GeomFromText(ST_AsText(ST_ConvexHull(ST_Collect(linestring))),4326) boundary, 
	'W'::text suburb_type, way_suburb_name.v suburb_name 
from ways
join way_tags boundary on ways.id = boundary.way_id and boundary.k = 'boundary' and boundary.v = 'administrative'
join way_tags admin_level on ways.id = admin_level.way_id and admin_level.k = 'admin_level' and cast(admin_level.v as int) > 8 
join way_tags way_suburb_name on ways.id = way_suburb_name.way_id and way_suburb_name.k = 'name'
group by ways.id, way_suburb_name.v
union
-- suburb relations
select rsuburbs.*, rel_suburb_name.v suburb_name from 
(
select relation_id id, 
	ST_GeomFromText(ST_AsText(ST_Centroid(ST_ConvexHull(ST_Collect(linestring)))),4326) centroid, 
	ST_GeomFromText(ST_AsText(ST_ConvexHull(ST_Collect(linestring))),4326) boundary, 
	'R'::text suburb_type from ( 
	select relation_members.relation_id, ways.linestring
	from relation_members 
	join ways on ways.id = relation_members.member_id and relation_members.member_type='W' 
	join relation_tags tag_type on relation_members.relation_id = tag_type.relation_id and tag_type.k = 'type' and tag_type.v = 'boundary'
	join relation_tags boundary on relation_members.relation_id = boundary.relation_id and boundary.k = 'boundary' and boundary.v = 'administrative'
	join relation_tags admin_level on relation_members.relation_id = admin_level.relation_id and admin_level.k = 'admin_level' and cast(admin_level.v as int) > 8 
 ) sub group by relation_id
) rsuburbs 
join relation_tags rel_suburb_name on rsuburbs.id = rel_suburb_name.relation_id and rel_suburb_name.k = 'name'
union
-- suburb nodes
select id, geom centroid, geom boundary, 'N'::text suburb_type, nd_suburb_name.v suburb_name from nodes join node_tags on nodes.id = node_tags.node_id and node_tags.k = 'place' and node_tags.v = 'suburb' join node_tags nd_suburb_name on nodes.id = nd_suburb_name.node_id and nd_suburb_name.k = 'name'
) suburb
join extra_comuni on ST_Covers(extra_comuni.boundary, suburb.boundary)
;

create index extra_suburbs_index_1 on extra_suburbs using gist(centroid);

create index extra_suburbs_index_2 on extra_suburbs using gist(boundary);

-- Corrispondenze tra elementi stradali, comuni e quartieri

drop table if exists extra_toponym_city ;

create table extra_toponym_city (
	id serial primary key,
	global_way_id bigint,
	local_way_id int,
	city varchar(255), 		
	suburb varchar(255)		
);

insert into extra_toponym_city(global_way_id, local_way_id, city) 
select highways.global_id global_way_id,
highways.local_id local_way_id,
nome_comune.v city 
from 
(
-- ways in relation roads
select extra_ways.global_id, extra_ways.local_id, 
extra_ways.start_node start_pt,
extra_ways.end_node end_pt
from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_ways on rwt.way_id = extra_ways.global_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'
union
-- ways in relation pedestrian multipolygon 
select extra_ways.global_id, extra_ways.local_id, 
extra_ways.start_node start_pt,
extra_ways.end_node end_pt
from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_ways on r_ways.member_id = extra_ways.global_id 
union
-- ways that are roads
select extra_ways.global_id, extra_ways.local_id, 
extra_ways.start_node start_pt,
extra_ways.end_node end_pt
from way_tags wt
join extra_ways on wt.way_id = extra_ways.global_id
  left join relation_members rm on rm.member_type = 'W' and rm.member_id = wt.way_id and rm.relation_id in 
(
select r.id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
)
 where wt.k = 'highway' 
   and wt.v <> 'proposed'
   and rm.member_id is null
) highways
join extra_comuni comuni on ST_Covers(comuni.boundary, highways.start_pt) or ST_Covers(comuni.boundary, highways.end_pt)
join relation_tags nome_comune on comuni.relation_id = nome_comune.relation_id and nome_comune.k = 'name';

update extra_toponym_city 
set suburb = suburb.suburb_name
from (

select i_suburb.global_way_id, i_suburb.local_way_id, suburb_name from (
select highways.global_way_id, highways.local_way_id,
coalesce(way_suburb_name.v, rel_suburb_name.v) suburb_name,
dense_rank() over (partition by highways.global_way_id, highways.local_way_id, coalesce(way_suburb_name.v, rel_suburb_name.v) order by cast(coalesce(way_suburb_level.v, rel_suburb_level.v) as int) desc) suburb_rank
from
(
-- ways in relation roads
select extra_ways.global_id global_way_id, extra_ways.local_id local_way_id, 
extra_ways.start_node start_pt,
extra_ways.end_node end_pt
from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_ways on rwt.way_id = extra_ways.global_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'
union
-- ways in relation pedestrian multipolygon 
select extra_ways.global_id, extra_ways.local_id, 
extra_ways.start_node start_pt,
extra_ways.end_node end_pt
from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_ways on r_ways.member_id = extra_ways.global_id 
union
-- ways that are roads
select extra_ways.global_id global_way_id, extra_ways.local_id local_way_id, 
extra_ways.start_node start_pt,
extra_ways.end_node end_pt
from way_tags wt
join extra_ways on wt.way_id = extra_ways.global_id
  left join relation_members rm on rm.member_type = 'W' and rm.member_id = wt.way_id and rm.relation_id in 
(
select r.id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
)
 where wt.k = 'highway' 
   and wt.v <> 'proposed'
   and rm.member_id is null
) highways
join extra_suburbs st_end_suburb on ST_Covers(st_end_suburb.boundary, highways.start_pt) and ST_Covers(st_end_suburb.boundary, highways.end_pt)
left join way_tags way_suburb_name on st_end_suburb.id = way_suburb_name.way_id and way_suburb_name.k = 'name'
left join relation_tags rel_suburb_name on st_end_suburb.id = rel_suburb_name.relation_id and rel_suburb_name.k = 'name'
left join way_tags way_suburb_level on st_end_suburb.id = way_suburb_level.way_id and way_suburb_level.k = 'admin_level'
left join relation_tags rel_suburb_level on st_end_suburb.id = rel_suburb_level.relation_id and rel_suburb_level.k = 'admin_level'

) i_suburb where suburb_rank = 1

) suburb 
where extra_toponym_city.global_way_id = suburb.global_way_id and extra_toponym_city.local_way_id = suburb.local_way_id;

drop table if exists i_way_tags;

create table i_way_tags as
select * from way_tags where not k like '%conditional%' 
union
select * from way_tags where k like '%conditional%' and (way_id, k) not in ( select way_id, k from (
select splitted.way_id, splitted.k, splitted.splitted_v from (
select *, unnest(regexp_split_to_array(v, ';(?![^\(]*\))')) splitted_v from way_tags  where k like '%conditional%' and v like '%;%'
) splitted 
join
(
select *, unnest(regexp_matches(v, '(;(?![^\(]*\)))([ \t]*)(yes|no|private|permissive|destination|delivery|customers|designated|use_sidepath|dismount|agricoltural|forestry|discouraged)')) matched_in_v from way_tags where k like '%conditional%' and v like '%;%'
) to_be_splitted
on splitted.way_id = to_be_splitted.way_id and splitted.k = to_be_splitted.k
) foo )
union 
select splitted.way_id, splitted.k, trim(splitted.splitted_v) v from (
select *, unnest(regexp_split_to_array(v, ';(?![^\(]*\))')) splitted_v from way_tags  where k like '%conditional%' and v like '%;%'
) splitted 
join
(
select *, unnest(regexp_matches(v, '(;(?![^\(]*\)))([ \t]*)(yes|no|private|permissive|destination|delivery|customers|designated|use_sidepath|dismount|agricoltural|forestry|discouraged)')) matched_in_v from way_tags where k like '%conditional%' and v like '%;%'
) to_be_splitted
on splitted.way_id = to_be_splitted.way_id and splitted.k = to_be_splitted.k
;

drop table if exists i_relation_tags;

create table i_relation_tags as
select * from relation_tags where not k like '%conditional%' 
union
select * from relation_tags where k like '%conditional%' and (relation_id, k) not in ( select relation_id, k from (
select splitted.relation_id, splitted.k, splitted.splitted_v from (
select *, unnest(regexp_split_to_array(v, ';(?![^\(]*\))')) splitted_v from relation_tags  where k like '%conditional%' and v like '%;%'
) splitted 
join
(
select *, unnest(regexp_matches(v, '(;(?![^\(]*\)))([ \t]*)(yes|no|private|permissive|destination|delivery|customers|designated|use_sidepath|dismount|agricoltural|forestry|discouraged)')) matched_in_v from relation_tags where k like '%conditional%' and v like '%;%'
) to_be_splitted
on splitted.relation_id = to_be_splitted.relation_id and splitted.k = to_be_splitted.k
) foo )
union 
select splitted.relation_id, splitted.k, trim(splitted.splitted_v) v from (
select *, unnest(regexp_split_to_array(v, ';(?![^\(]*\))')) splitted_v from relation_tags  where k like '%conditional%' and v like '%;%'
) splitted 
join
(
select *, unnest(regexp_matches(v, '(;(?![^\(]*\)))([ \t]*)(yes|no|private|permissive|destination|delivery|customers|designated|use_sidepath|dismount|agricoltural|forestry|discouraged)')) matched_in_v from relation_tags where k like '%conditional%' and v like '%;%'
) to_be_splitted
on splitted.relation_id = to_be_splitted.relation_id and splitted.k = to_be_splitted.k
;

------------- Lanes tagged on ways

-- Count

drop table if exists lanes_count;

create table lanes_count as 
select distinct
graph.graph_uri,
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where,
case when tag_lanes.k like '%forward%' then 'forward' when tag_lanes.k like '%backward%' then 'backward' else null end p_direction ,
t.description p_who ,
tag_lanes.v lanes_count
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_lanes on ways.id = tag_lanes.way_id and tag_lanes.k like '%lanes%' and tag_lanes.v ~ '^[0-9\.]+$'
left join land_based_transportation t on tag_lanes.k = t.description or tag_lanes.k like t.description || ':%' or tag_lanes.k like '%:' || t.description || ':%' or tag_lanes.k like '%:' || t.description 
join extra_config_graph graph on 1=1
where trim(replace(replace(replace(replace(tag_lanes.k,coalesce(t.description,''),''),'forward',''),'backward',''),':','')) = 'lanes';

-- Turns

drop table if exists lanes_turn;

create table lanes_turn as
select distinct
graph_uri,
p_where,
p_direction,
pos,
turns[pos] turn
from 
(
select
graph.graph_uri,
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where,
case when tag_turn.k like '%forward%' then 'forward' when tag_turn.k like '%backward%' then 'backward' else null end p_direction ,
string_to_array(tag_turn.v, '|') turns,
generate_subscripts(string_to_array(tag_turn.v, '|'),1) as pos
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_turn on ways.id = tag_turn.way_id and tag_turn.k like '%turn%' and tag_turn.k like '%lanes%'
join extra_config_graph graph on 1=1
) unsorted_turns 
order by graph_uri, p_where, p_direction, pos; 

-- Access

drop table if exists lanes_access;

create table lanes_access as
select
graph_uri,
p_where,
p_direction,
p_who,
p_condition,
pos,
access_restrictions[pos] restriction
from 
(
select distinct
graph.graph_uri, 
p_where,
string_to_array(p_access, '|') access_restrictions,
generate_subscripts(string_to_array(p_access, '|'),1) pos,
p_direction,
p_who,
nullif(trim(coalesce(readytouse_condition,'') || ' ' || coalesce(day_onoff,'') || ' ' || coalesce(date_onoff,'') || ' ' || coalesce(hour_onoff,'')),'') p_condition
from (
select 
case when way_relation.relation_uri is null then 'OS' || lpad(tag_access.way_id::text,11,'0') || 'SR' else 'OS' || lpad(tag_access.way_id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
case when position('@' in tag_access.v) = 0 then tag_access.v else trim(substring(tag_access.v,1,-1+position('@' in tag_access.v))) end p_access, 
nullif(coalesce(tag_day_on.v,'') || case when tag_day_on.v is null or tag_day_off.v is null then '' else ' - ' end || coalesce(tag_day_off.v,''),'') day_onoff,
nullif(coalesce(tag_date_on.v,'') || case when tag_date_on.v is null or tag_date_off.v is null then '' else ' - ' end || coalesce(tag_date_off.v,'') ,'') date_onoff,
nullif(coalesce(tag_hour_on.v,'') || case when tag_hour_on.v is null or tag_hour_off.v is null then '' else ' - ' end || coalesce(tag_hour_off.v,''), '')  hour_onoff,
case when tag_access.k like '%forward%' then 'forward' when tag_access.k like '%backward%' then 'backward' else null end p_direction ,
t.description p_who ,
case when position('@' in tag_access.v) > 1 then trim(substring(tag_access.v, 1+position('@' in tag_access.v))) else null end readytouse_condition
from 
ways 
join extra_ways on ways.id = extra_ways.global_id
join i_way_tags tag_access on ways.id = tag_access.way_id
left join way_tags tag_day_on on tag_access.way_id = tag_day_on.way_id and tag_day_on.k = 'day_on'
left join way_tags tag_day_off on tag_access.way_id = tag_day_off.way_id and tag_day_off.k = 'day_off'
left join way_tags tag_date_on on tag_access.way_id = tag_date_on.way_id and tag_date_on.k = 'date_on'
left join way_tags tag_date_off on tag_access.way_id = tag_date_off.way_id and tag_date_off.k = 'date_off'
left join way_tags tag_hour_on on tag_access.way_id = tag_hour_on.way_id and tag_hour_on.k = 'hour_on'
left join way_tags tag_hour_off on tag_access.way_id = tag_hour_off.way_id and tag_hour_off.k = 'hour_off'
left join land_based_transportation t on tag_access.k = t.description or tag_access.k like t.description || ':%' or tag_access.k like '%:' || t.description || ':%' or tag_access.k like '%:' || t.description 
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
where ( tag_access.k like '%lanes%' and ( tag_access.k like '%access%' or t.description is not null ) ) 
) node_access
join extra_config_graph graph on 1=1
) unsorted_restrictions
where access_restrictions[pos] in ('yes','no','private','permissive','destination','delivery','customers','designated','use_sidepath','dismount','agricoltural','forestry','discouraged')
order by graph_uri, p_where, p_direction, p_who, p_condition, pos;

-- Measures 

drop table if exists lanes_maxweight;

create table lanes_maxweight as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxweights[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxweight, '|') maxweights,
generate_subscripts(string_to_array(p_maxweight, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'maxweight' p_what,
case when position('@' in tag_maxweight.v) = 0 then tag_maxweight.v else trim(substring(tag_maxweight.v,1,-1+position('@' in tag_maxweight.v))) end p_maxweight, 
case when tag_maxweight.k like '%forward%' then 'forward' when tag_maxweight.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxweight.v) > 1 then trim(substring(tag_maxweight.v, 1+position('@' in tag_maxweight.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_maxweight on ways.id = tag_maxweight.way_id and tag_maxweight.k like '%maxweight%' and tag_maxweight.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restriction
) unordered 
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

drop table if exists lanes_maxwidth;

create table lanes_maxwidth as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxwidths[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxwidth, '|') maxwidths,
generate_subscripts(string_to_array(p_maxwidth, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'maxwidth' p_what,
case when position('@' in tag_maxwidth.v) = 0 then tag_maxwidth.v else trim(substring(tag_maxwidth.v,1,-1+position('@' in tag_maxwidth.v))) end p_maxwidth, 
case when tag_maxwidth.k like '%forward%' then 'forward' when tag_maxwidth.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxwidth.v) > 1 then trim(substring(tag_maxwidth.v, 1+position('@' in tag_maxwidth.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_maxwidth on ways.id = tag_maxwidth.way_id and tag_maxwidth.k like '%maxwidth%' and tag_maxwidth.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unordered
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

drop table if exists lanes_maxaxleload;

create table lanes_maxaxleload as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxaxleloads[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxaxleload, '|') maxaxleloads,
generate_subscripts(string_to_array(p_maxaxleload, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'maxaxleload' p_what,
case when position('@' in tag_maxaxleload.v) = 0 then tag_maxaxleload.v else trim(substring(tag_maxaxleload.v,1,-1+position('@' in tag_maxaxleload.v))) end p_maxaxleload, 
case when tag_maxaxleload.k like '%forward%' then 'forward' when tag_maxaxleload.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxaxleload.v) > 1 then trim(substring(tag_maxaxleload.v, 1+position('@' in tag_maxaxleload.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_maxaxleload on ways.id = tag_maxaxleload.way_id and tag_maxaxleload.k like '%maxaxleload%' and tag_maxaxleload.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restriction
) unordered
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

drop table if exists lanes_maxheight;

create table lanes_maxheight as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxheights[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxheight, '|') maxheights,
generate_subscripts(string_to_array(p_maxheight, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'maxheight' p_what,
case when position('@' in tag_maxheight.v) = 0 then tag_maxheight.v else trim(substring(tag_maxheight.v,1,-1+position('@' in tag_maxheight.v))) end p_maxheight, 
case when tag_maxheight.k like '%forward%' then 'forward' when tag_maxheight.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxheight.v) > 1 then trim(substring(tag_maxheight.v, 1+position('@' in tag_maxheight.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_maxheight on ways.id = tag_maxheight.way_id and tag_maxheight.k like '%maxheight%' and tag_maxheight.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

drop table if exists lanes_maxlength;

create table lanes_maxlength as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxlengths[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxlength, '|') maxlengths,
generate_subscripts(string_to_array(p_maxlength, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'maxlength' p_what,
case when position('@' in tag_maxlength.v) = 0 then tag_maxlength.v else trim(substring(tag_maxlength.v,1,-1+position('@' in tag_maxlength.v))) end p_maxlength, 
case when tag_maxlength.k like '%forward%' then 'forward' when tag_maxlength.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxlength.v) > 1 then trim(substring(tag_maxlength.v, 1+position('@' in tag_maxlength.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_maxlength on ways.id = tag_maxlength.way_id and tag_maxlength.k like '%maxlength%' and tag_maxlength.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

drop table if exists lanes_maxdraught;

create table lanes_maxdraught as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxdraughts[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxdraught, '|') maxdraughts,
generate_subscripts(string_to_array(p_maxdraught, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'maxdraught' p_what,
case when position('@' in tag_maxdraught.v) = 0 then tag_maxdraught.v else trim(substring(tag_maxdraught.v,1,-1+position('@' in tag_maxdraught.v))) end p_maxdraught, 
case when tag_maxdraught.k like '%forward%' then 'forward' when tag_maxdraught.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxdraught.v) > 1 then trim(substring(tag_maxdraught.v, 1+position('@' in tag_maxdraught.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_maxdraught on ways.id = tag_maxdraught.way_id and tag_maxdraught.k like '%maxdraught%' and tag_maxdraught.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

drop table if exists lanes_maxspeed;

create table lanes_maxspeed as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxspeeds[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxspeed, '|') maxspeeds,
generate_subscripts(string_to_array(p_maxspeed, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'maxspeed' p_what,
case when position('@' in tag_maxspeed.v) = 0 then tag_maxspeed.v else trim(substring(tag_maxspeed.v,1,-1+position('@' in tag_maxspeed.v))) end p_maxspeed, 
case when tag_maxspeed.k like '%forward%' then 'forward' when tag_maxspeed.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxspeed.v) > 1 then trim(substring(tag_maxspeed.v, 1+position('@' in tag_maxspeed.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_maxspeed on ways.id = tag_maxspeed.way_id and tag_maxspeed.k like '%maxspeed%' and tag_maxspeed.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

drop table if exists lanes_minspeed;

create table lanes_minspeed as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
minspeeds[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_minspeed, '|') minspeeds,
generate_subscripts(string_to_array(p_minspeed, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'minspeed' p_what,
case when position('@' in tag_minspeed.v) = 0 then tag_minspeed.v else trim(substring(tag_minspeed.v,1,-1+position('@' in tag_minspeed.v))) end p_minspeed, 
case when tag_minspeed.k like '%forward%' then 'forward' when tag_minspeed.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_minspeed.v) > 1 then trim(substring(tag_minspeed.v, 1+position('@' in tag_minspeed.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_minspeed on ways.id = tag_minspeed.way_id and tag_minspeed.k like '%minspeed%' and tag_minspeed.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

drop table if exists lanes_maxstay;

create table lanes_maxstay as
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxstays[pos] p_limit
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxstay, '|') maxstays,
generate_subscripts(string_to_array(p_maxstay, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
case when way_relation.relation_uri is null then 'OS' || lpad(ways.id::text,11,'0') || 'SR' else 'OS' || lpad(ways.id::text,11,'0') || 'RE/' || extra_ways.local_id end p_where, 
'maxstay' p_what,
case when position('@' in tag_maxstay.v) = 0 then tag_maxstay.v else trim(substring(tag_maxstay.v,1,-1+position('@' in tag_maxstay.v))) end p_maxstay, 
case when tag_maxstay.k like '%forward%' then 'forward' when tag_maxstay.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxstay.v) > 1 then trim(substring(tag_maxstay.v, 1+position('@' in tag_maxstay.v))) else null end p_condition
from ways
join extra_ways on ways.id = extra_ways.global_id
left join (
select distinct 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) way_relation on ways.id = way_relation.member_id
join way_tags tag_maxstay on ways.id = tag_maxstay.way_id and tag_maxstay.k like '%maxstay%' and tag_maxstay.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

------------ Lanes tagged on relations

-- Count

insert into lanes_count
select distinct
graph.graph_uri,
relations.relation_uri p_where,
case when tag_lanes.k like '%forward%' then 'forward' when tag_lanes.k like '%backward%' then 'backward' else null end p_direction ,
t.description p_who ,
tag_lanes.v lanes_count
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_lanes on relations.id = tag_lanes.relation_id and tag_lanes.k like '%lanes%' and tag_lanes.v ~ '^[0-9\.]+$'
left join land_based_transportation t on tag_lanes.k = t.description or tag_lanes.k like t.description || ':%' or tag_lanes.k like '%:' || t.description || ':%' or tag_lanes.k like '%:' || t.description 
join extra_config_graph graph on 1=1
where trim(replace(replace(replace(replace(tag_lanes.k,coalesce(t.description,''),''),'forward',''),'backward',''),':','')) = 'lanes';

-- Turns

insert into lanes_turn 
select distinct
graph_uri,
p_where,
p_direction,
pos,
turns[pos] turn
from 
(
select
graph.graph_uri,
relations.relation_uri p_where,
case when tag_turn.k like '%forward%' then 'forward' when tag_turn.k like '%backward%' then 'backward' else null end p_direction ,
string_to_array(tag_turn.v, '|') turns,
generate_subscripts(string_to_array(tag_turn.v, '|'),1) as pos
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_turn on relations.id = tag_turn.relation_id and tag_turn.k like '%turn%' and tag_turn.k like '%lanes%'
join extra_config_graph graph on 1=1
) unsorted_turns 
order by graph_uri, p_where, p_direction, pos; 

-- Access

insert into lanes_access 
select
graph_uri,
p_where,
p_direction,
p_who,
p_condition,
pos,
access_restrictions[pos] restriction
from 
(
select distinct
graph.graph_uri, 
p_where,
string_to_array(p_access, '|') access_restrictions,
generate_subscripts(string_to_array(p_access, '|'),1) pos,
p_direction,
p_who,
nullif(trim(coalesce(readytouse_condition,'') || ' ' || coalesce(day_onoff,'') || ' ' || coalesce(date_onoff,'') || ' ' || coalesce(hour_onoff,'')),'') p_condition
from (
select 
relations.relation_uri p_where, 
case when position('@' in tag_access.v) = 0 then tag_access.v else trim(substring(tag_access.v,1,-1+position('@' in tag_access.v))) end p_access, 
nullif(coalesce(tag_day_on.v,'') || case when tag_day_on.v is null or tag_day_off.v is null then '' else ' - ' end || coalesce(tag_day_off.v,''),'') day_onoff,
nullif(coalesce(tag_date_on.v,'') || case when tag_date_on.v is null or tag_date_off.v is null then '' else ' - ' end || coalesce(tag_date_off.v,'') ,'') date_onoff,
nullif(coalesce(tag_hour_on.v,'') || case when tag_hour_on.v is null or tag_hour_off.v is null then '' else ' - ' end || coalesce(tag_hour_off.v,''), '')  hour_onoff,
case when tag_access.k like '%forward%' then 'forward' when tag_access.k like '%backward%' then 'backward' else null end p_direction ,
t.description p_who ,
case when position('@' in tag_access.v) > 1 then trim(substring(tag_access.v, 1+position('@' in tag_access.v))) else null end readytouse_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join i_relation_tags tag_access on relations.id = tag_access.relation_id
left join relation_tags tag_day_on on tag_access.relation_id = tag_day_on.relation_id and tag_day_on.k = 'day_on'
left join relation_tags tag_day_off on tag_access.relation_id = tag_day_off.relation_id and tag_day_off.k = 'day_off'
left join relation_tags tag_date_on on tag_access.relation_id = tag_date_on.relation_id and tag_date_on.k = 'date_on'
left join relation_tags tag_date_off on tag_access.relation_id = tag_date_off.relation_id and tag_date_off.k = 'date_off'
left join relation_tags tag_hour_on on tag_access.relation_id = tag_hour_on.relation_id and tag_hour_on.k = 'hour_on'
left join relation_tags tag_hour_off on tag_access.relation_id = tag_hour_off.relation_id and tag_hour_off.k = 'hour_off'
left join land_based_transportation t on tag_access.k = t.description or tag_access.k like t.description || ':%' or tag_access.k like '%:' || t.description || ':%' or tag_access.k like '%:' || t.description 
where ( tag_access.k like '%lanes%' and ( tag_access.k like '%access%' or t.description is not null ) ) 
) node_access
join extra_config_graph graph on 1=1
) unsorted_restrictions
where access_restrictions[pos] in ('yes','no','private','permissive','destination','delivery','customers','designated','use_sidepath','dismount','agricoltural','forestry','discouraged')
order by graph_uri, p_where, p_direction, p_who, p_condition, pos;

-- Measures 

insert into lanes_maxweight 
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxweights[pos] maxweight
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxweight, '|') maxweights,
generate_subscripts(string_to_array(p_maxweight, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'maxweight' p_what,
case when position('@' in tag_maxweight.v) = 0 then tag_maxweight.v else trim(substring(tag_maxweight.v,1,-1+position('@' in tag_maxweight.v))) end p_maxweight, 
case when tag_maxweight.k like '%forward%' then 'forward' when tag_maxweight.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxweight.v) > 1 then trim(substring(tag_maxweight.v, 1+position('@' in tag_maxweight.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_maxweight on relations.id = tag_maxweight.relation_id and tag_maxweight.k like '%maxweight%' and tag_maxweight.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restriction
) unordered 
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

insert into lanes_maxwidth 
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxwidths[pos] maxwidths
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxwidth, '|') maxwidths,
generate_subscripts(string_to_array(p_maxwidth, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'maxwidth' p_what,
case when position('@' in tag_maxwidth.v) = 0 then tag_maxwidth.v else trim(substring(tag_maxwidth.v,1,-1+position('@' in tag_maxwidth.v))) end p_maxwidth, 
case when tag_maxwidth.k like '%forward%' then 'forward' when tag_maxwidth.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxwidth.v) > 1 then trim(substring(tag_maxwidth.v, 1+position('@' in tag_maxwidth.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_maxwidth on relations.id = tag_maxwidth.relation_id and tag_maxwidth.k like '%maxwidth%' and tag_maxwidth.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unordered
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

insert into lanes_maxaxleload
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxaxleloads[pos] maxaxleload
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxaxleload, '|') maxaxleloads,
generate_subscripts(string_to_array(p_maxaxleload, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'maxaxleload' p_what,
case when position('@' in tag_maxaxleload.v) = 0 then tag_maxaxleload.v else trim(substring(tag_maxaxleload.v,1,-1+position('@' in tag_maxaxleload.v))) end p_maxaxleload, 
case when tag_maxaxleload.k like '%forward%' then 'forward' when tag_maxaxleload.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxaxleload.v) > 1 then trim(substring(tag_maxaxleload.v, 1+position('@' in tag_maxaxleload.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_maxaxleload on relations.id = tag_maxaxleload.relation_id and tag_maxaxleload.k like '%maxaxleload%' and tag_maxaxleload.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restriction
) unordered
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

insert into lanes_maxheight 
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxheights[pos] maxheight
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxheight, '|') maxheights,
generate_subscripts(string_to_array(p_maxheight, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'maxheight' p_what,
case when position('@' in tag_maxheight.v) = 0 then tag_maxheight.v else trim(substring(tag_maxheight.v,1,-1+position('@' in tag_maxheight.v))) end p_maxheight, 
case when tag_maxheight.k like '%forward%' then 'forward' when tag_maxheight.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxheight.v) > 1 then trim(substring(tag_maxheight.v, 1+position('@' in tag_maxheight.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_maxheight on relations.id = tag_maxheight.relation_id and tag_maxheight.k like '%maxheight%' and tag_maxheight.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

insert into lanes_maxlength 
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxlengths[pos] maxlength
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxlength, '|') maxlengths,
generate_subscripts(string_to_array(p_maxlength, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'maxlength' p_what,
case when position('@' in tag_maxlength.v) = 0 then tag_maxlength.v else trim(substring(tag_maxlength.v,1,-1+position('@' in tag_maxlength.v))) end p_maxlength, 
case when tag_maxlength.k like '%forward%' then 'forward' when tag_maxlength.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxlength.v) > 1 then trim(substring(tag_maxlength.v, 1+position('@' in tag_maxlength.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_maxlength on relations.id = tag_maxlength.relation_id and tag_maxlength.k like '%maxlength%' and tag_maxlength.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

insert into lanes_maxdraught
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxdraughts[pos] maxdraught
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxdraught, '|') maxdraughts,
generate_subscripts(string_to_array(p_maxdraught, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'maxdraught' p_what,
case when position('@' in tag_maxdraught.v) = 0 then tag_maxdraught.v else trim(substring(tag_maxdraught.v,1,-1+position('@' in tag_maxdraught.v))) end p_maxdraught, 
case when tag_maxdraught.k like '%forward%' then 'forward' when tag_maxdraught.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxdraught.v) > 1 then trim(substring(tag_maxdraught.v, 1+position('@' in tag_maxdraught.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_maxdraught on relations.id = tag_maxdraught.relation_id and tag_maxdraught.k like '%maxdraught%' and tag_maxdraught.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

insert into lanes_maxspeed
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxspeeds[pos] maxspeed
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxspeed, '|') maxspeeds,
generate_subscripts(string_to_array(p_maxspeed, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'maxspeed' p_what,
case when position('@' in tag_maxspeed.v) = 0 then tag_maxspeed.v else trim(substring(tag_maxspeed.v,1,-1+position('@' in tag_maxspeed.v))) end p_maxspeed, 
case when tag_maxspeed.k like '%forward%' then 'forward' when tag_maxspeed.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxspeed.v) > 1 then trim(substring(tag_maxspeed.v, 1+position('@' in tag_maxspeed.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_maxspeed on relations.id = tag_maxspeed.relation_id and tag_maxspeed.k like '%maxspeed%' and tag_maxspeed.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

insert into lanes_minspeed
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
minspeeds[pos] minspeed
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_minspeed, '|') minspeeds,
generate_subscripts(string_to_array(p_minspeed, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'minspeed' p_what,
case when position('@' in tag_minspeed.v) = 0 then tag_minspeed.v else trim(substring(tag_minspeed.v,1,-1+position('@' in tag_minspeed.v))) end p_minspeed, 
case when tag_minspeed.k like '%forward%' then 'forward' when tag_minspeed.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_minspeed.v) > 1 then trim(substring(tag_minspeed.v, 1+position('@' in tag_minspeed.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_minspeed on relations.id = tag_minspeed.relation_id and tag_minspeed.k like '%minspeed%' and tag_minspeed.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;

insert into lanes_maxstay
select 
graph_uri,
p_where,
p_what,
p_direction,
p_condition,
pos,
maxstays[pos] maxstay
from 
(
select 
graph_uri,
p_where,
p_what,
string_to_array(p_maxstay, '|') maxstays,
generate_subscripts(string_to_array(p_maxstay, '|'), 1 ) pos,
p_direction,
p_condition
from (
select distinct
graph.graph_uri, 
relations.relation_uri p_where, 
'maxstay' p_what,
case when position('@' in tag_maxstay.v) = 0 then tag_maxstay.v else trim(substring(tag_maxstay.v,1,-1+position('@' in tag_maxstay.v))) end p_maxstay, 
case when tag_maxstay.k like '%forward%' then 'forward' when tag_maxstay.k like '%backward%' then 'backward' else null end p_direction ,
case when position('@' in tag_maxstay.v) > 1 then trim(substring(tag_maxstay.v, 1+position('@' in tag_maxstay.v))) else null end p_condition
from (
select distinct r.id, 'OS' || lpad(r.id::text,11,'0') || 'LR' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'route'
  left join relation_tags r_route on r.id = r_route.relation_id and r_route.k = 'route'
  left join relation_tags r_network on r.id = r_network.relation_id and r_network.k = 'network'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join way_tags rwt on r_ways.member_id = rwt.way_id and rwt.k = 'highway'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
 where COALESCE(r_route.v,'road') = 'road'
   and COALESCE(r_network.v, '--') <> 'e-road' 
   and rwt.v <> 'proposed'  
 union -- pedestrian relations (squares)
select r.id, 'OS' || lpad(r.id::text,11,'0') || 'SQ' relation_uri, r_ways.member_id
  from relations r
  join relation_tags r_type on r.id = r_type.relation_id and r_type.k = 'type' and r_type.v = 'multipolygon'
  join relation_tags r_pedestrian on r.id = r_pedestrian.relation_id and r_pedestrian.k = 'highway' and r_pedestrian.v = 'pedestrian'
  join relation_members r_ways on r.id = r_ways.relation_id and r_ways.member_type = 'W'
  join extra_toponym_city e on r_ways.member_id = e.global_way_id 
) relations
join relation_tags tag_maxstay on relations.id = tag_maxstay.relation_id and tag_maxstay.k like '%maxstay%' and tag_maxstay.k like '%lanes%'
join extra_config_graph graph on 1=1
) lanes_restrictions
) unsorted
order by graph_uri, p_where, p_what, p_direction, p_condition, pos;
